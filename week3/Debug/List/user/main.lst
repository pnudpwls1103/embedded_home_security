###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         01/Dec/2022  20:29:22
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =  C:\Embedded\week3\user\main.c
#    Command line      =
#        -f C:\Embedded\week3\Debug\Obj\user\main.o.rsp
#        (C:\Embedded\week3\user\main.c -D USE_STDPERIPH_DRIVER -D STM32F10X_CL
#        -lC C:\Embedded\week3\Debug\List\user -o
#        C:\Embedded\week3\Debug\Obj\user --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.1\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Embedded\week3\libraries\CMSIS\DeviceSupport\ -I
#        C:\Embedded\week3\libraries\CMSIS\DeviceSupport\Startup\ -I
#        C:\Embedded\week3\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\ -I
#        C:\Embedded\week3\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\ -I
#        C:\Embedded\week3\user\ -I C:\Embedded\week3\libraries\LCD\ -I
#        C:\Embedded\week3\user\inc\ -Ol -I "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\CMSIS\Core\Include\\")
#        --dependencies=n C:\Embedded\week3\Debug\Obj\user\main.o.d
#    Locale            =  C
#    List file         =  C:\Embedded\week3\Debug\List\user\main.lst
#    Object file       =  C:\Embedded\week3\Debug\Obj\user\main.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#      __size_limit    =  32768|ARM.EW.LINKER
#
###############################################################################

C:\Embedded\week3\user\main.c
      1          #include "stm32f10x.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD409             BMI.N    ??__NVIC_EnableIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable8
   \       0x14   0xB240             SXTB     R0,R0
   \       0x16   0x0940             LSRS     R0,R0,#+5
   \       0x18   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x1C   0x4770             BX       LR
      2          #include "core_cm3.h"
      3          #include "misc.h"
      4          #include "stm32f10x_gpio.h"
      5          #include "stm32f10x_rcc.h"
      6          #include "stm32f10x_usart.h"
      7          #include "stm32f10x_adc.h"
      8          #include "lcd.h"
      9          #include "touch.h"
     10          
     11          // volatile unsigned 32bits

   \                                 In section .bss, align 4
     12          volatile uint32_t ADC_Value[2];
   \                     ADC_Value:
   \        0x0                      DS8 8
     13          
     14          /* function prototype */
     15          void RCCInit(void);
     16          void GpioInit(void);
     17          void EXTI_Configure(void);
     18          void DMA_Configure(void);
     19          void ADC_Configure(void);
     20          void NVIC_Configure(void);
     21          void TIM_Configure(void);
     22          
     23          void EXTI1_IRQHandler(void);
     24          void EXTI15_10_IRQHandler(void);
     25          void Delay(void);
     26          void ControlPWM(int PWM);
     27          

   \                                 In section .bss, align 4
     28          int sensorFlag = 0;
   \                     sensorFlag:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     29          int btnFlag = 0;
   \                     btnFlag:
   \        0x0                      DS8 4
     30          

   \                                 In section .data, align 4
     31          unsigned int idx = -1;
   \                     idx:
   \        0x0   0xFFFF'FFFF        DC32 4'294'967'295

   \                                 In section .data, align 4
     32          int angle[] = {1000, 1500, 2000};
   \                     angle:
   \        0x0   0x0000'03E8        DC32 1'000, 1'500, 2'000

   \              0x0000'05DC  

   \              0x0000'07D0
     33          

   \                                 In section .text, align 2, keep-with-next
     34          void RCCInit(void)
     35          {	
   \                     RCCInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     36                  // 가스센서 ADC
     37                  RCC_APB2PeriphClockCmd(RCC_APB2ENR_ADC1EN, ENABLE);
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0xF44F 0x7000      MOV      R0,#+512
   \        0x8   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     38                  RCC_AHBPeriphClockCmd(RCC_AHBENR_DMA1EN, ENABLE);
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x.... 0x....      BL       RCC_AHBPeriphClockCmd
     39                  RCC_APB2PeriphClockCmd(RCC_APB2ENR_AFIOEN, ENABLE);
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     40                  
     41                  // 인체감지센서, PWM Digital pin
     42                  RCC_APB2PeriphClockCmd(RCC_APB2ENR_IOPBEN, ENABLE);
   \       0x1C   0x2101             MOVS     R1,#+1
   \       0x1E   0x2008             MOVS     R0,#+8
   \       0x20   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     43                  
     44                  // 릴레이모듈 (부저)
     45                  RCC_APB2PeriphClockCmd(RCC_APB2ENR_IOPCEN, ENABLE);
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0x2010             MOVS     R0,#+16
   \       0x28   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     46                  RCC_APB2PeriphClockCmd(RCC_APB2ENR_IOPDEN, ENABLE);
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x2020             MOVS     R0,#+32
   \       0x30   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     47                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   \       0x34   0x2101             MOVS     R1,#+1
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     48                  
     49                  // TIMER
     50                  RCC_APB1PeriphClockCmd(RCC_APB1ENR_TIM3EN, ENABLE);
   \       0x3C   0x2101             MOVS     R1,#+1
   \       0x3E   0x2002             MOVS     R0,#+2
   \       0x40   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     51                  
     52                  // PWM - 서보모터(PB0)
     53                  RCC_APB2PeriphClockCmd(RCC_APB2ENR_IOPBEN, ENABLE);
   \       0x44   0x2101             MOVS     R1,#+1
   \       0x46   0x2008             MOVS     R0,#+8
   \       0x48   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     54                  
     55          }
   \       0x4C   0xBD01             POP      {R0,PC}
     56          
     57          

   \                                 In section .text, align 2, keep-with-next
     58          void GpioInit(void)
     59          {
   \                     GpioInit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
     60                  GPIO_InitTypeDef GPIO_InitStructure;
     61                  
     62                  // 가스센서 (PB5)
     63                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
   \        0x2   0x2020             MOVS     R0,#+32
   \        0x4   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     64                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \        0x8   0x2003             MOVS     R0,#+3
   \        0xA   0xF88D 0x0002      STRB     R0,[SP, #+2]
     65                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xF88D 0x0003      STRB     R0,[SP, #+3]
     66                  GPIO_Init(GPIOA, &GPIO_InitStructure);
   \       0x14   0x4669             MOV      R1,SP
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \       0x1A   0x.... 0x....      BL       GPIO_Init
     67                  
     68                  // 인체감지센서 (PB1)
     69                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     70                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x24   0x2003             MOVS     R0,#+3
   \       0x26   0xF88D 0x0002      STRB     R0,[SP, #+2]
     71                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \       0x2A   0x2028             MOVS     R0,#+40
   \       0x2C   0xF88D 0x0003      STRB     R0,[SP, #+3]
     72                  GPIO_Init(GPIOB, &GPIO_InitStructure);
   \       0x30   0x.... 0x....      LDR.W    R4,??DataTable8_2
   \       0x34   0x4669             MOV      R1,SP
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x.... 0x....      BL       GPIO_Init
     73                  
     74                  // 버튼 (PD11)
     75                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
   \       0x3C   0xF44F 0x6000      MOV      R0,#+2048
   \       0x40   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     76                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x44   0x2003             MOVS     R0,#+3
   \       0x46   0xF88D 0x0002      STRB     R0,[SP, #+2]
     77                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \       0x4A   0x2048             MOVS     R0,#+72
   \       0x4C   0xF88D 0x0003      STRB     R0,[SP, #+3]
     78                  GPIO_Init(GPIOD, &GPIO_InitStructure);
   \       0x50   0x4669             MOV      R1,SP
   \       0x52   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \       0x56   0x.... 0x....      BL       GPIO_Init
     79                  
     80                  // 펌프 - 릴레이모듈 (PC8)
     81                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
   \       0x5A   0xF44F 0x7080      MOV      R0,#+256
   \       0x5E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     82                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x62   0x2003             MOVS     R0,#+3
   \       0x64   0xF88D 0x0002      STRB     R0,[SP, #+2]
     83                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \       0x68   0x2010             MOVS     R0,#+16
   \       0x6A   0xF88D 0x0003      STRB     R0,[SP, #+3]
     84                  GPIO_Init(GPIOC, &GPIO_InitStructure);
   \       0x6E   0x....             LDR.N    R5,??DataTable8_4
   \       0x70   0x4669             MOV      R1,SP
   \       0x72   0x0028             MOVS     R0,R5
   \       0x74   0x.... 0x....      BL       GPIO_Init
     85                  
     86                  // 블루투스 - 릴레이모듈 (PC9)
     87                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \       0x78   0xF44F 0x7000      MOV      R0,#+512
   \       0x7C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     88                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x80   0x2003             MOVS     R0,#+3
   \       0x82   0xF88D 0x0002      STRB     R0,[SP, #+2]
     89                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \       0x86   0x2010             MOVS     R0,#+16
   \       0x88   0xF88D 0x0003      STRB     R0,[SP, #+3]
     90                  GPIO_Init(GPIOC, &GPIO_InitStructure);
   \       0x8C   0x4669             MOV      R1,SP
   \       0x8E   0x0028             MOVS     R0,R5
   \       0x90   0x.... 0x....      BL       GPIO_Init
     91                  
     92                  // TIMER
     93                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
   \       0x94   0x2001             MOVS     R0,#+1
   \       0x96   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     94                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x9A   0x2003             MOVS     R0,#+3
   \       0x9C   0xF88D 0x0002      STRB     R0,[SP, #+2]
     95                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \       0xA0   0x2018             MOVS     R0,#+24
   \       0xA2   0xF88D 0x0003      STRB     R0,[SP, #+3]
     96                  GPIO_Init(GPIOB, &GPIO_InitStructure);    
   \       0xA6   0x4669             MOV      R1,SP
   \       0xA8   0x0020             MOVS     R0,R4
   \       0xAA   0x.... 0x....      BL       GPIO_Init
     97          }
   \       0xAE   0xBD31             POP      {R0,R4,R5,PC}
     98          

   \                                 In section .text, align 2, keep-with-next
     99          void EXTI_Configure(void)
    100          {
   \                     EXTI_Configure: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    101                  EXTI_InitTypeDef EXTI_InitStructure;
    102                  
    103                  // 인체감지센서 EXTI (PB1)
    104                  GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource1);
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x.... 0x....      BL       GPIO_EXTILineConfig
    105                  EXTI_InitStructure.EXTI_Line = EXTI_Line1;
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0x9000             STR      R0,[SP, #+0]
    106                  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xF88D 0x0004      STRB     R0,[SP, #+4]
    107                  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
   \       0x14   0x2010             MOVS     R0,#+16
   \       0x16   0xF88D 0x0005      STRB     R0,[SP, #+5]
    108                  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xF88D 0x0006      STRB     R0,[SP, #+6]
    109                  EXTI_Init(&EXTI_InitStructure);
   \       0x20   0x4668             MOV      R0,SP
   \       0x22   0x.... 0x....      BL       EXTI_Init
    110                  
    111                  // 버튼 EXTI (PD11)
    112                  GPIO_EXTILineConfig(GPIO_PortSourceGPIOD, GPIO_PinSource11);
   \       0x26   0x210B             MOVS     R1,#+11
   \       0x28   0x2003             MOVS     R0,#+3
   \       0x2A   0x.... 0x....      BL       GPIO_EXTILineConfig
    113                  EXTI_InitStructure.EXTI_Line = EXTI_Line11;
   \       0x2E   0xF44F 0x6000      MOV      R0,#+2048
   \       0x32   0x9000             STR      R0,[SP, #+0]
    114                  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF88D 0x0004      STRB     R0,[SP, #+4]
    115                  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \       0x3A   0x200C             MOVS     R0,#+12
   \       0x3C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    116                  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0xF88D 0x0006      STRB     R0,[SP, #+6]
    117                  EXTI_Init(&EXTI_InitStructure);
   \       0x46   0x4668             MOV      R0,SP
   \       0x48   0x.... 0x....      BL       EXTI_Init
    118          }
   \       0x4C   0xBD07             POP      {R0-R2,PC}
    119          

   \                                 In section .text, align 2, keep-with-next
    120          void DMA_Configure(void) {
   \                     DMA_Configure: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB08B             SUB      SP,SP,#+44
    121                  DMA_InitTypeDef DMA_Instructure;
    122                  
    123                  DMA_Instructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC1->DR;
   \        0x4   0x....             LDR.N    R0,??DataTable8_5
   \        0x6   0x9000             STR      R0,[SP, #+0]
    124                  DMA_Instructure.DMA_MemoryBaseAddr = (uint32_t)&ADC_Value[1];
   \        0x8   0x....             LDR.N    R0,??DataTable8_6
   \        0xA   0x9001             STR      R0,[SP, #+4]
    125                  DMA_Instructure.DMA_DIR = DMA_DIR_PeripheralSRC;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x9002             STR      R0,[SP, #+8]
    126                  DMA_Instructure.DMA_BufferSize = 1;
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x9003             STR      R0,[SP, #+12]
    127                  DMA_Instructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x9004             STR      R0,[SP, #+16]
    128                  DMA_Instructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
   \       0x18   0x2080             MOVS     R0,#+128
   \       0x1A   0x9005             STR      R0,[SP, #+20]
    129                  DMA_Instructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
   \       0x1C   0xF44F 0x7000      MOV      R0,#+512
   \       0x20   0x9006             STR      R0,[SP, #+24]
    130                  DMA_Instructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
   \       0x22   0xF44F 0x6000      MOV      R0,#+2048
   \       0x26   0x9007             STR      R0,[SP, #+28]
    131                  DMA_Instructure.DMA_Mode = DMA_Mode_Circular;
   \       0x28   0x2020             MOVS     R0,#+32
   \       0x2A   0x9008             STR      R0,[SP, #+32]
    132                  DMA_Instructure.DMA_Priority = DMA_Priority_High;
   \       0x2C   0xF44F 0x5000      MOV      R0,#+8192
   \       0x30   0x9009             STR      R0,[SP, #+36]
    133                  DMA_Instructure.DMA_M2M = DMA_M2M_Enable;
   \       0x32   0xF44F 0x4080      MOV      R0,#+16384
   \       0x36   0x900A             STR      R0,[SP, #+40]
    134                  
    135                  DMA_Init(DMA1_Channel1, &DMA_Instructure);
   \       0x38   0x....             LDR.N    R4,??DataTable8_7
   \       0x3A   0x4669             MOV      R1,SP
   \       0x3C   0x0020             MOVS     R0,R4
   \       0x3E   0x.... 0x....      BL       DMA_Init
    136                  DMA_Cmd(DMA1_Channel1, ENABLE);
   \       0x42   0x2101             MOVS     R1,#+1
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       DMA_Cmd
    137          
    138          }
   \       0x4A   0xB00C             ADD      SP,SP,#+48
   \       0x4C   0xBD10             POP      {R4,PC}
    139          

   \                                 In section .text, align 2, keep-with-next
    140          void ADC_Configure(void)
    141          {
   \                     ADC_Configure: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
    142                  ADC_InitTypeDef ADC_InitStructure;
    143                  
    144                  ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
    145                  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xF88D 0x0004      STRB     R0,[SP, #+4]
    146                  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF88D 0x0005      STRB     R0,[SP, #+5]
    147                  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   \       0x14   0xF45F 0x2060      MOVS     R0,#+917504
   \       0x18   0x9002             STR      R0,[SP, #+8]
    148                  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x9003             STR      R0,[SP, #+12]
    149                  ADC_InitStructure.ADC_NbrOfChannel = 1;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xF88D 0x0010      STRB     R0,[SP, #+16]
    150                
    151                  ADC_Init(ADC1, &ADC_InitStructure);
   \       0x24   0x....             LDR.N    R4,??DataTable8_8
   \       0x26   0x4669             MOV      R1,SP
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x.... 0x....      BL       ADC_Init
    152                  
    153                  ADC_RegularChannelConfig(ADC1, ADC_Channel_5, 1, ADC_SampleTime_41Cycles5);
   \       0x2E   0x2304             MOVS     R3,#+4
   \       0x30   0x2201             MOVS     R2,#+1
   \       0x32   0x2105             MOVS     R1,#+5
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       ADC_RegularChannelConfig
    154                  
    155                  ADC_DMACmd(ADC1, ENABLE);
   \       0x3A   0x2101             MOVS     R1,#+1
   \       0x3C   0x0020             MOVS     R0,R4
   \       0x3E   0x.... 0x....      BL       ADC_DMACmd
    156                  
    157                  ADC_Cmd(ADC1, ENABLE);
   \       0x42   0x2101             MOVS     R1,#+1
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       ADC_Cmd
    158                  
    159                  ADC_ResetCalibration(ADC1);
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x.... 0x....      BL       ADC_ResetCalibration
    160                  
    161                  while(ADC_GetResetCalibrationStatus(ADC1)) {}
   \                     ??ADC_Configure_0: (+1)
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0x.... 0x....      BL       ADC_GetResetCalibrationStatus
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD1FA             BNE.N    ??ADC_Configure_0
    162                  
    163                  ADC_StartCalibration(ADC1);
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x.... 0x....      BL       ADC_StartCalibration
    164                  
    165                  while(ADC_GetCalibrationStatus(ADC1)) {}
   \                     ??ADC_Configure_1: (+1)
   \       0x60   0x0020             MOVS     R0,R4
   \       0x62   0x.... 0x....      BL       ADC_GetCalibrationStatus
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD1FA             BNE.N    ??ADC_Configure_1
    166                  
    167                  ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   \       0x6A   0x2101             MOVS     R1,#+1
   \       0x6C   0x0020             MOVS     R0,R4
   \       0x6E   0x.... 0x....      BL       ADC_SoftwareStartConvCmd
    168                  
    169          }
   \       0x72   0xB006             ADD      SP,SP,#+24
   \       0x74   0xBD10             POP      {R4,PC}
    170          

   \                                 In section .text, align 2, keep-with-next
    171          void NVIC_Configure(void)
    172          {
   \                     NVIC_Configure: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    173                  NVIC_InitTypeDef NVIC_InitStructure;
    174          
    175                  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
   \        0x2   0xF44F 0x60C0      MOV      R0,#+1536
   \        0x6   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    176                  
    177                  // 인체감지센서 NVIC
    178                  NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;
   \        0xA   0x2007             MOVS     R0,#+7
   \        0xC   0xF88D 0x0000      STRB     R0,[SP, #+0]
    179                  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x1;
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF88D 0x0001      STRB     R0,[SP, #+1]
    180                  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x1;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xF88D 0x0002      STRB     R0,[SP, #+2]
    181                  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    182                  NVIC_Init(&NVIC_InitStructure);
   \       0x22   0x4668             MOV      R0,SP
   \       0x24   0x.... 0x....      BL       NVIC_Init
    183                  
    184                  // 버튼 NVIC
    185                  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
   \       0x28   0x2028             MOVS     R0,#+40
   \       0x2A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    186                  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x1;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xF88D 0x0001      STRB     R0,[SP, #+1]
    187                  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x1;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xF88D 0x0002      STRB     R0,[SP, #+2]
    188                  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    189                  NVIC_Init(&NVIC_InitStructure);
   \       0x40   0x4668             MOV      R0,SP
   \       0x42   0x.... 0x....      BL       NVIC_Init
    190                  
    191                  // PWM Timer3 NVIC
    192                  NVIC_EnableIRQ(TIM3_IRQn);
   \       0x46   0x201D             MOVS     R0,#+29
   \       0x48   0x.... 0x....      BL       __NVIC_EnableIRQ
    193                  NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
   \       0x4C   0x201D             MOVS     R0,#+29
   \       0x4E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    194                  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x1;
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0xF88D 0x0001      STRB     R0,[SP, #+1]
    195                  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x1;
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    196                  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0xF88D 0x0003      STRB     R0,[SP, #+3]
    197                  NVIC_Init(&NVIC_InitStructure);
   \       0x64   0x4668             MOV      R0,SP
   \       0x66   0x.... 0x....      BL       NVIC_Init
    198          }
   \       0x6A   0xBD01             POP      {R0,PC}
    199          

   \                                 In section .text, align 2, keep-with-next
    200          void TIM_Configure(void)
    201          {
   \                     TIM_Configure: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
    202                  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    203                  TIM_OCInitTypeDef       TIM_OCInitStructure;
    204                  
    205                  // TIM3_CH3 (PWM)
    206                  TIM_TimeBaseStructure.TIM_Period = 20000;
   \        0x4   0xF644 0x6020      MOVW     R0,#+20000
   \        0x8   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    207                  TIM_TimeBaseStructure.TIM_Prescaler = 72;
   \        0xC   0x2048             MOVS     R0,#+72
   \        0xE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    208                  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    209                  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Down;
   \       0x18   0x2010             MOVS     R0,#+16
   \       0x1A   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    210                  
    211                  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
   \       0x1E   0x2060             MOVS     R0,#+96
   \       0x20   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    212                  TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    213                  TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    214                  TIM_OCInitStructure.TIM_Pulse = 1500;
   \       0x30   0xF240 0x50DC      MOVW     R0,#+1500
   \       0x34   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    215                  TIM_OC3Init(TIM3, &TIM_OCInitStructure);
   \       0x38   0x....             LDR.N    R4,??DataTable8_9
   \       0x3A   0xA903             ADD      R1,SP,#+12
   \       0x3C   0x0020             MOVS     R0,R4
   \       0x3E   0x.... 0x....      BL       TIM_OC3Init
    216                  
    217                  TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
   \       0x42   0x4669             MOV      R1,SP
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       TIM_TimeBaseInit
    218                  TIM_OC3PreloadConfig(TIM3, TIM_OCPreload_Disable);
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x.... 0x....      BL       TIM_OC3PreloadConfig
    219                  TIM_ARRPreloadConfig(TIM3, ENABLE);
   \       0x52   0x2101             MOVS     R1,#+1
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0x.... 0x....      BL       TIM_ARRPreloadConfig
    220                  TIM_Cmd(TIM3, ENABLE);
   \       0x5A   0x2101             MOVS     R1,#+1
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       TIM_Cmd
    221          }
   \       0x62   0xB008             ADD      SP,SP,#+32
   \       0x64   0xBD10             POP      {R4,PC}
    222          

   \                                 In section .text, align 2, keep-with-next
    223          void EXTI1_IRQHandler() {
   \                     EXTI1_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    224              if (EXTI_GetITStatus(EXTI_Line1) != RESET) {
   \        0x2   0x2002             MOVS     R0,#+2
   \        0x4   0x.... 0x....      BL       EXTI_GetITStatus
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD00F             BEQ.N    ??EXTI1_IRQHandler_0
    225                  if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == Bit_SET) {
   \        0xC   0x2102             MOVS     R1,#+2
   \        0xE   0x....             LDR.N    R0,??DataTable8_2
   \       0x10   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD103             BNE.N    ??EXTI1_IRQHandler_1
    226                      sensorFlag = 1;
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x....             LDR.N    R1,??DataTable8_10
   \       0x1C   0x6008             STR      R0,[R1, #+0]
   \       0x1E   0xE002             B.N      ??EXTI1_IRQHandler_2
    227                  }
    228                  else {
    229                      sensorFlag = 0;
   \                     ??EXTI1_IRQHandler_1: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x....             LDR.N    R1,??DataTable8_10
   \       0x24   0x6008             STR      R0,[R1, #+0]
    230                  }
    231                  EXTI_ClearITPendingBit(EXTI_Line1);
   \                     ??EXTI1_IRQHandler_2: (+1)
   \       0x26   0x2002             MOVS     R0,#+2
   \       0x28   0x.... 0x....      BL       EXTI_ClearITPendingBit
    232              }
    233          
    234          
    235          }
   \                     ??EXTI1_IRQHandler_0: (+1)
   \       0x2C   0xBD01             POP      {R0,PC}
    236          

   \                                 In section .text, align 2, keep-with-next
    237          void EXTI15_10_IRQHandler() {
   \                     EXTI15_10_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    238              if (EXTI_GetITStatus(EXTI_Line11) != RESET) {
   \        0x2   0xF44F 0x6000      MOV      R0,#+2048
   \        0x6   0x.... 0x....      BL       EXTI_GetITStatus
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD023             BEQ.N    ??EXTI15_10_IRQHandler_0
    239                  if (GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_11) == Bit_RESET){
   \        0xE   0xF44F 0x6100      MOV      R1,#+2048
   \       0x12   0x....             LDR.N    R0,??DataTable8_3
   \       0x14   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD118             BNE.N    ??EXTI15_10_IRQHandler_1
    240                      idx++;
   \       0x1C   0x....             LDR.N    R0,??DataTable8_11
   \       0x1E   0x6801             LDR      R1,[R0, #+0]
   \       0x20   0x1C49             ADDS     R1,R1,#+1
   \       0x22   0x6001             STR      R1,[R0, #+0]
    241                      ControlPWM(angle[idx%3]);
   \       0x24   0x2103             MOVS     R1,#+3
   \       0x26   0x6802             LDR      R2,[R0, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x2E   0xFB01 0x2110      MLS      R1,R1,R0,R2
   \       0x32   0x....             LDR.N    R0,??DataTable8_12
   \       0x34   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \       0x38   0x.... 0x....      BL       ControlPWM
    242                      btnFlag = (btnFlag == 0) ? 1 : 0;
   \       0x3C   0x....             LDR.N    R1,??DataTable8_13
   \       0x3E   0x6808             LDR      R0,[R1, #+0]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD102             BNE.N    ??EXTI15_10_IRQHandler_2
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x6008             STR      R0,[R1, #+0]
   \       0x48   0xE001             B.N      ??EXTI15_10_IRQHandler_1
   \                     ??EXTI15_10_IRQHandler_2: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x6008             STR      R0,[R1, #+0]
    243                  }
    244          
    245                  EXTI_ClearITPendingBit(EXTI_Line11);
   \                     ??EXTI15_10_IRQHandler_1: (+1)
   \       0x4E   0xF44F 0x6000      MOV      R0,#+2048
   \       0x52   0x.... 0x....      BL       EXTI_ClearITPendingBit
    246              }
    247          
    248          
    249          }
   \                     ??EXTI15_10_IRQHandler_0: (+1)
   \       0x56   0xBD01             POP      {R0,PC}
    250          

   \                                 In section .text, align 2, keep-with-next
    251          void ControlPWM(int PWM) {
   \                     ControlPWM: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    252                  TIM_OCInitTypeDef       TIM_OCInitStructure;
    253                  
    254                  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
   \        0x2   0x2160             MOVS     R1,#+96
   \        0x4   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    255                  TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0xF8AD 0x1008      STRH     R1,[SP, #+8]
    256                  TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    257                  TIM_OCInitStructure.TIM_Pulse = PWM;
   \       0x14   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    258                  TIM_OC3Init(TIM3, &TIM_OCInitStructure);
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0x....             LDR.N    R0,??DataTable8_9
   \       0x1C   0x.... 0x....      BL       TIM_OC3Init
    259          }
   \       0x20   0xB005             ADD      SP,SP,#+20
   \       0x22   0xBD00             POP      {PC}
    260          

   \                                 In section .text, align 2, keep-with-next
    261          int main(void)
    262          {
   \                     main: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    263            	SystemInit();
   \        0x2   0x.... 0x....      BL       SystemInit
    264                  RCCInit();
   \        0x6   0x.... 0x....      BL       RCCInit
    265                  GpioInit();
   \        0xA   0x.... 0x....      BL       GpioInit
    266                  EXTI_Configure();
   \        0xE   0x.... 0x....      BL       EXTI_Configure
    267                  DMA_Configure();
   \       0x12   0x.... 0x....      BL       DMA_Configure
    268                  ADC_Configure();
   \       0x16   0x.... 0x....      BL       ADC_Configure
    269                  TIM_Configure();
   \       0x1A   0x.... 0x....      BL       TIM_Configure
    270                  NVIC_Configure();
   \       0x1E   0x.... 0x....      BL       NVIC_Configure
    271                  
    272                  //GPIO_ResetBits(GPIOC, GPIO_Pin_8);
    273                  //GPIO_ResetBits(GPIOC, GPIO_Pin_9);
    274                  
    275          	LCD_Init();
   \       0x22   0x.... 0x....      BL       LCD_Init
    276          	Touch_Configuration();
   \       0x26   0x.... 0x....      BL       Touch_Configuration
    277          	Touch_Adjust();
   \       0x2A   0x.... 0x....      BL       Touch_Adjust
    278          	LCD_Clear(WHITE);	       
   \       0x2E   0xF64F 0x74FF      MOVW     R4,#+65535
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       LCD_Clear
    279                  
    280                  LCD_ShowString(80, 120, "Gas: ", BLACK, WHITE);
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x9000             STR      R0,[SP, #+0]
   \       0x3C   0x2300             MOVS     R3,#+0
   \       0x3E   0x....             LDR.N    R2,??DataTable8_14
   \       0x40   0x2178             MOVS     R1,#+120
   \       0x42   0x2050             MOVS     R0,#+80
   \       0x44   0x.... 0x....      BL       LCD_ShowString
    281                  LCD_ShowString(80, 140, "Motion: ", BLACK, WHITE);
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x9000             STR      R0,[SP, #+0]
   \       0x4C   0x2300             MOVS     R3,#+0
   \       0x4E   0x....             LDR.N    R2,??DataTable8_15
   \       0x50   0x218C             MOVS     R1,#+140
   \       0x52   0x2050             MOVS     R0,#+80
   \       0x54   0x.... 0x....      BL       LCD_ShowString
    282                  LCD_ShowString(80, 160, "Button: ", BLACK, WHITE);
   \       0x58   0x0020             MOVS     R0,R4
   \       0x5A   0x9000             STR      R0,[SP, #+0]
   \       0x5C   0x2300             MOVS     R3,#+0
   \       0x5E   0x....             LDR.N    R2,??DataTable8_16
   \       0x60   0x21A0             MOVS     R1,#+160
   \       0x62   0x2050             MOVS     R0,#+80
   \       0x64   0x.... 0x....      BL       LCD_ShowString
    283                  
    284                  while(1) {
    285                          if(btnFlag)
    286                          {
    287                              //GPIO_SetBits(GPIOC, GPIO_Pin_8);
    288                              //GPIO_SetBits(GPIOC, GPIO_Pin_9);
    289                              //ControlPWM(1500);
    290                          }
    291                          else
    292                          {
    293                             // GPIO_ResetBits(GPIOC, GPIO_Pin_8);
    294                             // GPIO_ResetBits(GPIOC, GPIO_Pin_9);
    295                              //ControlPWM(1500);
    296                          }
    297                          
    298                         // LCD_ShowNum(100, 120, ADC_Value[1], 10, BLACK, WHITE);
    299                          //LCD_ShowNum(100, 140, sensorFlag, 10, BLACK, WHITE);
    300                          LCD_ShowNum(100, 160, btnFlag, 10, RED, WHITE);
   \                     ??main_0: (+1)
   \       0x68   0x0020             MOVS     R0,R4
   \       0x6A   0x9001             STR      R0,[SP, #+4]
   \       0x6C   0xF44F 0x4078      MOV      R0,#+63488
   \       0x70   0x9000             STR      R0,[SP, #+0]
   \       0x72   0x230A             MOVS     R3,#+10
   \       0x74   0x....             LDR.N    R0,??DataTable8_13
   \       0x76   0x6802             LDR      R2,[R0, #+0]
   \       0x78   0x21A0             MOVS     R1,#+160
   \       0x7A   0x2064             MOVS     R0,#+100
   \       0x7C   0x.... 0x....      BL       LCD_ShowNum
    301                          LCD_ShowNum(100, 180, idx%3, 10, RED, WHITE);
   \       0x80   0x2203             MOVS     R2,#+3
   \       0x82   0x....             LDR.N    R0,??DataTable8_11
   \       0x84   0x0021             MOVS     R1,R4
   \       0x86   0x9101             STR      R1,[SP, #+4]
   \       0x88   0xF44F 0x4178      MOV      R1,#+63488
   \       0x8C   0x9100             STR      R1,[SP, #+0]
   \       0x8E   0x230A             MOVS     R3,#+10
   \       0x90   0x6801             LDR      R1,[R0, #+0]
   \       0x92   0x6800             LDR      R0,[R0, #+0]
   \       0x94   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \       0x98   0xFB02 0x1210      MLS      R2,R2,R0,R1
   \       0x9C   0x21B4             MOVS     R1,#+180
   \       0x9E   0x2064             MOVS     R0,#+100
   \       0xA0   0x.... 0x....      BL       LCD_ShowNum
   \       0xA4   0xE7E0             B.N      ??main_0
    302                          
    303                          
    304          	}
    305          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x4001'0800        DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x4001'0C00        DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x4001'1400        DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x4001'1000        DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x4001'244C        DC32     0x4001244c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x....'....        DC32     ADC_Value+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0x4002'0008        DC32     0x40020008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \        0x0   0x4001'2400        DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \        0x0   0x4000'0400        DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \        0x0   0x....'....        DC32     sensorFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \        0x0   0x....'....        DC32     idx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \        0x0   0x....'....        DC32     angle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \        0x0   0x....'....        DC32     btnFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x47 0x61          DC8 "Gas: "

   \              0x73 0x3A    

   \              0x20 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x4D 0x6F          DC8 "Motion: "

   \              0x74 0x69    

   \              0x6F 0x6E    

   \              0x3A 0x20    

   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x42 0x75          DC8 "Button: "

   \              0x74 0x74    

   \              0x6F 0x6E    

   \              0x3A 0x20    

   \              0x00
   \        0x9                      DS8 3

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   ADC_Configure
        32   -> ADC_Cmd
        32   -> ADC_DMACmd
        32   -> ADC_GetCalibrationStatus
        32   -> ADC_GetResetCalibrationStatus
        32   -> ADC_Init
        32   -> ADC_RegularChannelConfig
        32   -> ADC_ResetCalibration
        32   -> ADC_SoftwareStartConvCmd
        32   -> ADC_StartCalibration
      24   ControlPWM
        24   -> TIM_OC3Init
      56   DMA_Configure
        56   -> DMA_Cmd
        56   -> DMA_Init
       8   EXTI15_10_IRQHandler
         8   -> ControlPWM
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> GPIO_ReadInputDataBit
       8   EXTI1_IRQHandler
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> GPIO_ReadInputDataBit
      16   EXTI_Configure
        16   -> EXTI_Init
        16   -> GPIO_EXTILineConfig
      16   GpioInit
        16   -> GPIO_Init
       8   NVIC_Configure
         8   -> NVIC_Init
         8   -> NVIC_PriorityGroupConfig
         8   -> __NVIC_EnableIRQ
       8   RCCInit
         8   -> RCC_AHBPeriphClockCmd
         8   -> RCC_APB1PeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd
      40   TIM_Configure
        40   -> TIM_ARRPreloadConfig
        40   -> TIM_Cmd
        40   -> TIM_OC3Init
        40   -> TIM_OC3PreloadConfig
        40   -> TIM_TimeBaseInit
       0   __NVIC_EnableIRQ
      16   main
        16   -> ADC_Configure
        16   -> DMA_Configure
        16   -> EXTI_Configure
        16   -> GpioInit
        16   -> LCD_Clear
        16   -> LCD_Init
        16   -> LCD_ShowNum
        16   -> LCD_ShowString
        16   -> NVIC_Configure
        16   -> RCCInit
        16   -> SystemInit
        16   -> TIM_Configure
        16   -> Touch_Adjust
        16   -> Touch_Configuration


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       8  ?_0
      12  ?_1
      12  ?_2
     118  ADC_Configure
       8  ADC_Value
      36  ControlPWM
      78  DMA_Configure
      88  EXTI15_10_IRQHandler
      46  EXTI1_IRQHandler
      78  EXTI_Configure
     176  GpioInit
     108  NVIC_Configure
      78  RCCInit
     102  TIM_Configure
      30  __NVIC_EnableIRQ
      12  angle
       4  btnFlag
       4  idx
     166  main
       4  sensorFlag

 
    16 bytes in section .bss
    16 bytes in section .data
    32 bytes in section .rodata
 1'172 bytes in section .text
 
 1'172 bytes of CODE  memory
    32 bytes of CONST memory
    32 bytes of DATA  memory

Errors: none
Warnings: none
