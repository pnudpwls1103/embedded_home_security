###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         22/Dec/2022  18:15:12
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =  C:\Embedded\week3\user\main.c
#    Command line      =
#        -f C:\Embedded\week3\Debug\Obj\user\main.o.rsp
#        (C:\Embedded\week3\user\main.c -D USE_STDPERIPH_DRIVER -D STM32F10X_CL
#        -lC C:\Embedded\week3\Debug\List\user -o
#        C:\Embedded\week3\Debug\Obj\user --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.1\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Embedded\week3\libraries\CMSIS\DeviceSupport\ -I
#        C:\Embedded\week3\libraries\CMSIS\DeviceSupport\Startup\ -I
#        C:\Embedded\week3\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\ -I
#        C:\Embedded\week3\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\ -I
#        C:\Embedded\week3\user\ -I C:\Embedded\week3\libraries\LCD\ -I
#        C:\Embedded\week3\user\inc\ -Ol -I "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\CMSIS\Core\Include\\")
#        --dependencies=n C:\Embedded\week3\Debug\Obj\user\main.o.d
#    Locale            =  C
#    List file         =  C:\Embedded\week3\Debug\List\user\main.lst
#    Object file       =  C:\Embedded\week3\Debug\Obj\user\main.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#      __size_limit    =  32768|ARM.EW.LINKER
#
###############################################################################

C:\Embedded\week3\user\main.c
      1          #include "stm32f10x.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD409             BMI.N    ??__NVIC_EnableIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable16
   \       0x14   0xB240             SXTB     R0,R0
   \       0x16   0x0940             LSRS     R0,R0,#+5
   \       0x18   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x1C   0x4770             BX       LR
      2          #include "core_cm3.h"
      3          #include "misc.h"
      4          #include "stm32f10x_gpio.h"
      5          #include "stm32f10x_rcc.h"
      6          #include "stm32f10x_usart.h"
      7          #include "stm32f10x_adc.h"
      8          #include "lcd.h"
      9          #include "touch.h"
     10          
     11          #define TEMPMAX 1000
     12          #define GASMAX  800
     13          

   \                                 In section .bss, align 2
     14          volatile uint16_t ADC_Value[1];
   \                     ADC_Value:
   \        0x0                      DS8 2
     15          

   \                                 In section .bss, align 4
     16          volatile int btnFlag = 0;
   \                     btnFlag:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     17          volatile int gasFlag = 0;
   \                     gasFlag:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     18          volatile int usartFlag = 0;
   \                     usartFlag:
   \        0x0                      DS8 4
     19          

   \                                 In section .data, align 4
     20          char password[] = {'1', '2', '3', '4'};
   \                     password:
   \        0x0   0x31 0x32          DC8 49, 50, 51, 52

   \              0x33 0x34
     21          
     22          

   \                                 In section .bss, align 4
     23          volatile int idx = 0;
   \                     idx:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     24          volatile int wrongflag = 0;
   \                     wrongflag:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     25          volatile int wrongcnt = 0;
   \                     wrongcnt:
   \        0x0                      DS8 4
     26          
     27          void RCCInit(void);
     28          void GpioInit(void);
     29          void EXTI_Configure(void);
     30          void DMA_Configure(void);
     31          void ADC_Configure(void);
     32          void NVIC_Configure(void);
     33          void TIM_Configure(void);
     34          void USART1_Init(void);
     35          void USRAT2_Init(void);
     36          
     37          void USART1_IRQHandler(void);
     38          void USART2_IRQHandler(void);
     39          void EXTI15_10_IRQHandler(void);
     40          void DMA1_Channel1_IRQHandler(void);
     41          
     42          void ControlPWM(int PWM);
     43          void SetFireAlarm(void);
     44          void ResetFireAlarm(void);
     45          char GetLCDNumber(uint16_t x, uint16_t y);
     46          

   \                                 In section .text, align 2, keep-with-next
     47          void RCCInit(void)
     48          {   
   \                     RCCInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     49                  // Althernate Function IO 
     50                  RCC_APB2PeriphClockCmd(RCC_APB2ENR_AFIOEN, ENABLE);
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     51                  
     52                  // 가스센서 ADC
     53                  RCC_APB2PeriphClockCmd(RCC_APB2ENR_ADC1EN, ENABLE);
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0xF44F 0x7000      MOV      R0,#+512
   \       0x10   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     54                  
     55                  // DMA
     56                  RCC_AHBPeriphClockCmd(RCC_AHBENR_DMA1EN, ENABLE);
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x.... 0x....      BL       RCC_AHBPeriphClockCmd
     57                  
     58                  // PWM Digital pin
     59                  RCC_APB2PeriphClockCmd(RCC_APB2ENR_IOPBEN, ENABLE);
   \       0x1C   0x2101             MOVS     R1,#+1
   \       0x1E   0x2008             MOVS     R0,#+8
   \       0x20   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     60                  
     61                  // 릴레이모듈 (부저)
     62                  RCC_APB2PeriphClockCmd(RCC_APB2ENR_IOPCEN, ENABLE);
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0x2010             MOVS     R0,#+16
   \       0x28   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     63                  RCC_APB2PeriphClockCmd(RCC_APB2ENR_IOPDEN, ENABLE);
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x2020             MOVS     R0,#+32
   \       0x30   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     64                  
     65                  // TIMER
     66                  RCC_APB1PeriphClockCmd(RCC_APB1ENR_TIM3EN, ENABLE);
   \       0x34   0x2101             MOVS     R1,#+1
   \       0x36   0x2002             MOVS     R0,#+2
   \       0x38   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     67          
     68                  // UART TX/RX
     69                  RCC_APB2PeriphClockCmd(RCC_APB2ENR_IOPAEN, ENABLE);
   \       0x3C   0x2101             MOVS     R1,#+1
   \       0x3E   0x2004             MOVS     R0,#+4
   \       0x40   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     70                  
     71                  // USART1
     72                  RCC_APB2PeriphClockCmd(RCC_APB2ENR_USART1EN, ENABLE);
   \       0x44   0x2101             MOVS     R1,#+1
   \       0x46   0xF44F 0x4080      MOV      R0,#+16384
   \       0x4A   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     73          
     74                  // UART2
     75                  RCC_APB1PeriphClockCmd(RCC_APB1ENR_USART2EN, ENABLE);
   \       0x4E   0x2101             MOVS     R1,#+1
   \       0x50   0xF45F 0x3000      MOVS     R0,#+131072
   \       0x54   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     76                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   \       0x58   0x2101             MOVS     R1,#+1
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     77          
     78          }
   \       0x60   0xBD01             POP      {R0,PC}
     79          
     80          

   \                                 In section .text, align 2, keep-with-next
     81          void GpioInit(void)
     82          {
   \                     GpioInit: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
     83                  GPIO_InitTypeDef GPIO_InitStructure;
     84                  
     85                  // 가스센서 (PA5)
     86                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
   \        0x2   0x2020             MOVS     R0,#+32
   \        0x4   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     87                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \        0x8   0x2003             MOVS     R0,#+3
   \        0xA   0xF88D 0x0002      STRB     R0,[SP, #+2]
     88                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xF88D 0x0003      STRB     R0,[SP, #+3]
     89                  GPIO_Init(GPIOA, &GPIO_InitStructure);
   \       0x14   0x.... 0x....      LDR.W    R4,??DataTable16_1
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       GPIO_Init
     90                  
     91                  // 버튼 (PD11)
     92                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
   \       0x20   0xF44F 0x6000      MOV      R0,#+2048
   \       0x24   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     93                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x28   0x2003             MOVS     R0,#+3
   \       0x2A   0xF88D 0x0002      STRB     R0,[SP, #+2]
     94                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \       0x2E   0x2048             MOVS     R0,#+72
   \       0x30   0xF88D 0x0003      STRB     R0,[SP, #+3]
     95                  GPIO_Init(GPIOD, &GPIO_InitStructure);
   \       0x34   0x4669             MOV      R1,SP
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \       0x3A   0x.... 0x....      BL       GPIO_Init
     96                  
     97                  // 펌프 - 릴레이모듈 (PC8)
     98                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9;
   \       0x3E   0xF44F 0x7040      MOV      R0,#+768
   \       0x42   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     99                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x46   0x2003             MOVS     R0,#+3
   \       0x48   0xF88D 0x0002      STRB     R0,[SP, #+2]
    100                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \       0x4C   0x2010             MOVS     R0,#+16
   \       0x4E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    101                  GPIO_Init(GPIOC, &GPIO_InitStructure);
   \       0x52   0x4669             MOV      R1,SP
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \       0x58   0x.... 0x....      BL       GPIO_Init
    102                  
    103                  // TIMER3_CH3 (PB0)
    104                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
   \       0x5C   0x2001             MOVS     R0,#+1
   \       0x5E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    105                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x62   0x2003             MOVS     R0,#+3
   \       0x64   0xF88D 0x0002      STRB     R0,[SP, #+2]
    106                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \       0x68   0x2018             MOVS     R0,#+24
   \       0x6A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    107                  GPIO_Init(GPIOB, &GPIO_InitStructure);
   \       0x6E   0x4669             MOV      R1,SP
   \       0x70   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \       0x74   0x.... 0x....      BL       GPIO_Init
    108          
    109                  // TX1(PA9) / TX2(PA2)
    110                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_2;
   \       0x78   0xF44F 0x7001      MOV      R0,#+516
   \       0x7C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    111                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x80   0x2003             MOVS     R0,#+3
   \       0x82   0xF88D 0x0002      STRB     R0,[SP, #+2]
    112                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \       0x86   0x2018             MOVS     R0,#+24
   \       0x88   0xF88D 0x0003      STRB     R0,[SP, #+3]
    113                  GPIO_Init(GPIOA, &GPIO_InitStructure);
   \       0x8C   0x4669             MOV      R1,SP
   \       0x8E   0x0020             MOVS     R0,R4
   \       0x90   0x.... 0x....      BL       GPIO_Init
    114                  
    115                  // RX1(PA10) / RX2(A3)
    116                  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_3;
   \       0x94   0xF44F 0x6081      MOV      R0,#+1032
   \       0x98   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    117                  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
   \       0x9C   0x2002             MOVS     R0,#+2
   \       0x9E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    118                  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \       0xA2   0x2048             MOVS     R0,#+72
   \       0xA4   0xF88D 0x0003      STRB     R0,[SP, #+3]
    119                  GPIO_Init(GPIOA, &GPIO_InitStructure);
   \       0xA8   0x4669             MOV      R1,SP
   \       0xAA   0x0020             MOVS     R0,R4
   \       0xAC   0x.... 0x....      BL       GPIO_Init
    120          
    121          
    122          }
   \       0xB0   0xBD13             POP      {R0,R1,R4,PC}
    123          

   \                                 In section .text, align 2, keep-with-next
    124          void EXTI_Configure(void)
    125          {
   \                     EXTI_Configure: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    126                  EXTI_InitTypeDef EXTI_InitStructure;
    127                  
    128                  // 버튼 EXTI (PD11)
    129                  GPIO_EXTILineConfig(GPIO_PortSourceGPIOD, GPIO_PinSource11);
   \        0x2   0x210B             MOVS     R1,#+11
   \        0x4   0x2003             MOVS     R0,#+3
   \        0x6   0x.... 0x....      BL       GPIO_EXTILineConfig
    130                  EXTI_InitStructure.EXTI_Line = EXTI_Line11;
   \        0xA   0xF44F 0x6000      MOV      R0,#+2048
   \        0xE   0x9000             STR      R0,[SP, #+0]
    131                  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xF88D 0x0004      STRB     R0,[SP, #+4]
    132                  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \       0x16   0x200C             MOVS     R0,#+12
   \       0x18   0xF88D 0x0005      STRB     R0,[SP, #+5]
    133                  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xF88D 0x0006      STRB     R0,[SP, #+6]
    134                  EXTI_Init(&EXTI_InitStructure);
   \       0x22   0x4668             MOV      R0,SP
   \       0x24   0x.... 0x....      BL       EXTI_Init
    135          }
   \       0x28   0xBD07             POP      {R0-R2,PC}
    136          

   \                                 In section .text, align 2, keep-with-next
    137          void DMA_Configure(void) {
   \                     DMA_Configure: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB08B             SUB      SP,SP,#+44
    138                  DMA_InitTypeDef DMA_Instructure;
    139          
    140                  DMA_Instructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC1->DR;
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \        0x8   0x9000             STR      R0,[SP, #+0]
    141                  DMA_Instructure.DMA_MemoryBaseAddr = (uint32_t)&ADC_Value[0];
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \        0xE   0x9001             STR      R0,[SP, #+4]
    142                  DMA_Instructure.DMA_DIR = DMA_DIR_PeripheralSRC;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x9002             STR      R0,[SP, #+8]
    143                  DMA_Instructure.DMA_BufferSize = 1;
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x9003             STR      R0,[SP, #+12]
    144                  DMA_Instructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x9004             STR      R0,[SP, #+16]
    145                  DMA_Instructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
   \       0x1C   0x2080             MOVS     R0,#+128
   \       0x1E   0x9005             STR      R0,[SP, #+20]
    146                  DMA_Instructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
   \       0x20   0xF44F 0x7080      MOV      R0,#+256
   \       0x24   0x9006             STR      R0,[SP, #+24]
    147                  DMA_Instructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
   \       0x26   0xF44F 0x6080      MOV      R0,#+1024
   \       0x2A   0x9007             STR      R0,[SP, #+28]
    148                  DMA_Instructure.DMA_Mode = DMA_Mode_Circular;
   \       0x2C   0x2020             MOVS     R0,#+32
   \       0x2E   0x9008             STR      R0,[SP, #+32]
    149                  DMA_Instructure.DMA_Priority = DMA_Priority_High;
   \       0x30   0xF44F 0x5000      MOV      R0,#+8192
   \       0x34   0x9009             STR      R0,[SP, #+36]
    150                  DMA_Instructure.DMA_M2M = DMA_M2M_Disable;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x900A             STR      R0,[SP, #+40]
    151                  
    152                  DMA_Init(DMA1_Channel1, &DMA_Instructure);
   \       0x3A   0x.... 0x....      LDR.W    R4,??DataTable16_7
   \       0x3E   0x4669             MOV      R1,SP
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x.... 0x....      BL       DMA_Init
    153                  DMA_Cmd(DMA1_Channel1, ENABLE);
   \       0x46   0x2101             MOVS     R1,#+1
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x.... 0x....      BL       DMA_Cmd
    154                  DMA_ITConfig(DMA1_Channel1, DMA_IT_TC, ENABLE);
   \       0x4E   0x2201             MOVS     R2,#+1
   \       0x50   0x2102             MOVS     R1,#+2
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x.... 0x....      BL       DMA_ITConfig
    155          }
   \       0x58   0xB00C             ADD      SP,SP,#+48
   \       0x5A   0xBD10             POP      {R4,PC}
    156          

   \                                 In section .text, align 2, keep-with-next
    157          void ADC_Configure(void)
    158          {
   \                     ADC_Configure: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
    159                  ADC_InitTypeDef ADC_InitStructure;
    160                  
    161                  ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
    162                  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xF88D 0x0004      STRB     R0,[SP, #+4]
    163                  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF88D 0x0005      STRB     R0,[SP, #+5]
    164                  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   \       0x14   0xF45F 0x2060      MOVS     R0,#+917504
   \       0x18   0x9002             STR      R0,[SP, #+8]
    165                  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x9003             STR      R0,[SP, #+12]
    166                  ADC_InitStructure.ADC_NbrOfChannel = 1;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xF88D 0x0010      STRB     R0,[SP, #+16]
    167                
    168                  ADC_Init(ADC1, &ADC_InitStructure);
   \       0x24   0x.... 0x....      LDR.W    R4,??DataTable16_8
   \       0x28   0x4669             MOV      R1,SP
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0x.... 0x....      BL       ADC_Init
    169          
    170                  ADC_RegularChannelConfig(ADC1, ADC_Channel_5, 1, ADC_SampleTime_41Cycles5);
   \       0x30   0x2304             MOVS     R3,#+4
   \       0x32   0x2201             MOVS     R2,#+1
   \       0x34   0x2105             MOVS     R1,#+5
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x.... 0x....      BL       ADC_RegularChannelConfig
    171          
    172                  ADC_DMACmd(ADC1, ENABLE);
   \       0x3C   0x2101             MOVS     R1,#+1
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x.... 0x....      BL       ADC_DMACmd
    173                  
    174                  ADC_Cmd(ADC1, ENABLE);
   \       0x44   0x2101             MOVS     R1,#+1
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0x.... 0x....      BL       ADC_Cmd
    175                  
    176                  ADC_ResetCalibration(ADC1);
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x.... 0x....      BL       ADC_ResetCalibration
    177                  
    178                  while(ADC_GetResetCalibrationStatus(ADC1)) {}
   \                     ??ADC_Configure_0: (+1)
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x.... 0x....      BL       ADC_GetResetCalibrationStatus
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD1FA             BNE.N    ??ADC_Configure_0
    179                  
    180                  ADC_StartCalibration(ADC1);
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       ADC_StartCalibration
    181                  
    182                  while(ADC_GetCalibrationStatus(ADC1)) {}
   \                     ??ADC_Configure_1: (+1)
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0x.... 0x....      BL       ADC_GetCalibrationStatus
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD1FA             BNE.N    ??ADC_Configure_1
    183                  
    184                  ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   \       0x6C   0x2101             MOVS     R1,#+1
   \       0x6E   0x0020             MOVS     R0,R4
   \       0x70   0x.... 0x....      BL       ADC_SoftwareStartConvCmd
    185                  
    186          }
   \       0x74   0xB006             ADD      SP,SP,#+24
   \       0x76   0xBD10             POP      {R4,PC}
    187          

   \                                 In section .text, align 2, keep-with-next
    188          void NVIC_Configure(void)
    189          {
   \                     NVIC_Configure: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    190                  NVIC_InitTypeDef NVIC_InitStructure;
    191          
    192                  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
   \        0x2   0xF44F 0x60C0      MOV      R0,#+1536
   \        0x6   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    193                  
    194                  // 버튼 NVIC
    195                  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
   \        0xA   0x2028             MOVS     R0,#+40
   \        0xC   0xF88D 0x0000      STRB     R0,[SP, #+0]
    196                  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x1;
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF88D 0x0001      STRB     R0,[SP, #+1]
    197                  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x1;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xF88D 0x0002      STRB     R0,[SP, #+2]
    198                  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    199                  NVIC_Init(&NVIC_InitStructure);
   \       0x22   0x4668             MOV      R0,SP
   \       0x24   0x.... 0x....      BL       NVIC_Init
    200                  
    201                  // PWM Timer3 NVIC
    202                  NVIC_EnableIRQ(TIM3_IRQn);
   \       0x28   0x201D             MOVS     R0,#+29
   \       0x2A   0x.... 0x....      BL       __NVIC_EnableIRQ
    203                  NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
   \       0x2E   0x201D             MOVS     R0,#+29
   \       0x30   0xF88D 0x0000      STRB     R0,[SP, #+0]
    204                  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x1;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xF88D 0x0001      STRB     R0,[SP, #+1]
    205                  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x1;
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    206                  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0xF88D 0x0003      STRB     R0,[SP, #+3]
    207                  NVIC_Init(&NVIC_InitStructure);
   \       0x46   0x4668             MOV      R0,SP
   \       0x48   0x.... 0x....      BL       NVIC_Init
    208                  
    209                  // DMA
    210                  NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel1_IRQn;
   \       0x4C   0x200B             MOVS     R0,#+11
   \       0x4E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    211                  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x1;
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0xF88D 0x0001      STRB     R0,[SP, #+1]
    212                  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x1;
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    213                  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0xF88D 0x0003      STRB     R0,[SP, #+3]
    214                  NVIC_Init(&NVIC_InitStructure);
   \       0x64   0x4668             MOV      R0,SP
   \       0x66   0x.... 0x....      BL       NVIC_Init
    215                  
    216                  // UART1
    217                  NVIC_EnableIRQ(USART1_IRQn);
   \       0x6A   0x2025             MOVS     R0,#+37
   \       0x6C   0x.... 0x....      BL       __NVIC_EnableIRQ
    218                  NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
   \       0x70   0x2025             MOVS     R0,#+37
   \       0x72   0xF88D 0x0000      STRB     R0,[SP, #+0]
    219                  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x1;
   \       0x76   0x2001             MOVS     R0,#+1
   \       0x78   0xF88D 0x0001      STRB     R0,[SP, #+1]
    220                  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x1;
   \       0x7C   0x2001             MOVS     R0,#+1
   \       0x7E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    221                  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0x82   0x2001             MOVS     R0,#+1
   \       0x84   0xF88D 0x0003      STRB     R0,[SP, #+3]
    222                  NVIC_Init(&NVIC_InitStructure);
   \       0x88   0x4668             MOV      R0,SP
   \       0x8A   0x.... 0x....      BL       NVIC_Init
    223          
    224                  // UART2
    225                  NVIC_EnableIRQ(USART2_IRQn);
   \       0x8E   0x2026             MOVS     R0,#+38
   \       0x90   0x.... 0x....      BL       __NVIC_EnableIRQ
    226                  NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
   \       0x94   0x2026             MOVS     R0,#+38
   \       0x96   0xF88D 0x0000      STRB     R0,[SP, #+0]
    227                  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x1;
   \       0x9A   0x2001             MOVS     R0,#+1
   \       0x9C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    228                  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x1;
   \       0xA0   0x2001             MOVS     R0,#+1
   \       0xA2   0xF88D 0x0002      STRB     R0,[SP, #+2]
    229                  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0xA6   0x2001             MOVS     R0,#+1
   \       0xA8   0xF88D 0x0003      STRB     R0,[SP, #+3]
    230                  NVIC_Init(&NVIC_InitStructure);
   \       0xAC   0x4668             MOV      R0,SP
   \       0xAE   0x.... 0x....      BL       NVIC_Init
    231          
    232          }
   \       0xB2   0xBD01             POP      {R0,PC}
    233          

   \                                 In section .text, align 2, keep-with-next
    234          void TIM_Configure(void)
    235          {
   \                     TIM_Configure: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
    236                  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    237                  TIM_OCInitTypeDef       TIM_OCInitStructure;
    238                  
    239                  // TIM3_CH3 (PWM)
    240                  TIM_TimeBaseStructure.TIM_Period = 20000;
   \        0x4   0xF644 0x6020      MOVW     R0,#+20000
   \        0x8   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    241                  TIM_TimeBaseStructure.TIM_Prescaler = 72;
   \        0xC   0x2048             MOVS     R0,#+72
   \        0xE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    242                  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    243                  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Down;
   \       0x18   0x2010             MOVS     R0,#+16
   \       0x1A   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    244                  
    245                  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
   \       0x1E   0x2060             MOVS     R0,#+96
   \       0x20   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    246                  TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    247                  TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    248                  TIM_OCInitStructure.TIM_Pulse = 1500;
   \       0x30   0xF240 0x50DC      MOVW     R0,#+1500
   \       0x34   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    249                  TIM_OC3Init(TIM3, &TIM_OCInitStructure);
   \       0x38   0x....             LDR.N    R4,??DataTable16_9
   \       0x3A   0xA903             ADD      R1,SP,#+12
   \       0x3C   0x0020             MOVS     R0,R4
   \       0x3E   0x.... 0x....      BL       TIM_OC3Init
    250                  
    251                  TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
   \       0x42   0x4669             MOV      R1,SP
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       TIM_TimeBaseInit
    252                  TIM_OC3PreloadConfig(TIM3, TIM_OCPreload_Disable);
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x.... 0x....      BL       TIM_OC3PreloadConfig
    253                  TIM_ARRPreloadConfig(TIM3, ENABLE);
   \       0x52   0x2101             MOVS     R1,#+1
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0x.... 0x....      BL       TIM_ARRPreloadConfig
    254                  TIM_Cmd(TIM3, ENABLE);
   \       0x5A   0x2101             MOVS     R1,#+1
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       TIM_Cmd
    255          }
   \       0x62   0xB008             ADD      SP,SP,#+32
   \       0x64   0xBD10             POP      {R4,PC}
    256          

   \                                 In section .text, align 2, keep-with-next
    257          void USART1_Init(void)
    258          {
   \                     USART1_Init: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
    259                  USART_InitTypeDef USART1_InitStructure;
    260          
    261                  USART_Cmd(USART1, ENABLE);
   \        0x2   0x....             LDR.N    R4,??DataTable16_10
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x.... 0x....      BL       USART_Cmd
    262                  
    263                  USART1_InitStructure.USART_WordLength = USART_WordLength_8b;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    264                  USART1_InitStructure.USART_StopBits = USART_StopBits_1;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    265                  USART1_InitStructure.USART_Parity = USART_Parity_No;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    266                  USART1_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    267                  USART1_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \       0x24   0x200C             MOVS     R0,#+12
   \       0x26   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    268                  USART1_InitStructure.USART_BaudRate = 9600;
   \       0x2A   0xF44F 0x5016      MOV      R0,#+9600
   \       0x2E   0x9000             STR      R0,[SP, #+0]
    269                  USART_Init(USART1, &USART1_InitStructure);
   \       0x30   0x4669             MOV      R1,SP
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       USART_Init
    270             
    271                  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
   \       0x38   0x2201             MOVS     R2,#+1
   \       0x3A   0xF240 0x5125      MOVW     R1,#+1317
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x.... 0x....      BL       USART_ITConfig
    272          }
   \       0x44   0xBD1F             POP      {R0-R4,PC}
    273          

   \                                 In section .text, align 2, keep-with-next
    274          void USART2_Init(void)
    275          {
   \                     USART2_Init: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
    276                  USART_InitTypeDef USART2_InitStructure;
    277          
    278                  USART_Cmd(USART2, ENABLE);
   \        0x2   0x....             LDR.N    R4,??DataTable16_11
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x.... 0x....      BL       USART_Cmd
    279                  
    280                  USART2_InitStructure.USART_WordLength = USART_WordLength_8b;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    281                  USART2_InitStructure.USART_StopBits = USART_StopBits_1;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    282                  USART2_InitStructure.USART_Parity = USART_Parity_No;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    283                  USART2_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    284                  USART2_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \       0x24   0x200C             MOVS     R0,#+12
   \       0x26   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    285                  USART2_InitStructure.USART_BaudRate = 9600;
   \       0x2A   0xF44F 0x5016      MOV      R0,#+9600
   \       0x2E   0x9000             STR      R0,[SP, #+0]
    286                  USART_Init(USART2, &USART2_InitStructure);
   \       0x30   0x4669             MOV      R1,SP
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       USART_Init
    287             
    288                  USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
   \       0x38   0x2201             MOVS     R2,#+1
   \       0x3A   0xF240 0x5125      MOVW     R1,#+1317
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x.... 0x....      BL       USART_ITConfig
    289             
    290          }
   \       0x44   0xBD1F             POP      {R0-R4,PC}
    291          

   \                                 In section .text, align 2, keep-with-next
    292          void USART1_IRQHandler()
    293          {
   \                     USART1_IRQHandler: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    294                  uint16_t word;
    295                  if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET){
   \        0x2   0x....             LDR.N    R4,??DataTable16_10
   \        0x4   0xF240 0x5525      MOVW     R5,#+1317
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x.... 0x....      BL       USART_GetITStatus
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD00B             BEQ.N    ??USART1_IRQHandler_0
    296                      word = USART_ReceiveData(USART1);
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x.... 0x....      BL       USART_ReceiveData
   \       0x1A   0x0001             MOVS     R1,R0
    297                      USART_SendData(USART2, word);
   \       0x1C   0xB289             UXTH     R1,R1
   \       0x1E   0x....             LDR.N    R0,??DataTable16_11
   \       0x20   0x.... 0x....      BL       USART_SendData
    298                      USART_ClearITPendingBit(USART1,USART_IT_RXNE);
   \       0x24   0x0029             MOVS     R1,R5
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       USART_ClearITPendingBit
    299                  }
    300          }
   \                     ??USART1_IRQHandler_0: (+1)
   \       0x2C   0xBD31             POP      {R0,R4,R5,PC}
    301          

   \                                 In section .text, align 2, keep-with-next
    302          void USART2_IRQHandler(void)
    303          {
   \                     USART2_IRQHandler: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    304                  uint16_t word;
    305                  if(USART_GetITStatus(USART2,USART_IT_RXNE)!=RESET){
   \        0x2   0x....             LDR.N    R5,??DataTable16_11
   \        0x4   0xF240 0x5625      MOVW     R6,#+1317
   \        0x8   0x0031             MOVS     R1,R6
   \        0xA   0x0028             MOVS     R0,R5
   \        0xC   0x.... 0x....      BL       USART_GetITStatus
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD016             BEQ.N    ??USART2_IRQHandler_0
    306                          word = USART_ReceiveData(USART2);
   \       0x14   0x0028             MOVS     R0,R5
   \       0x16   0x.... 0x....      BL       USART_ReceiveData
   \       0x1A   0x0004             MOVS     R4,R0
    307                          USART_SendData(USART1, word);
   \       0x1C   0x0021             MOVS     R1,R4
   \       0x1E   0xB289             UXTH     R1,R1
   \       0x20   0x....             LDR.N    R0,??DataTable16_10
   \       0x22   0x.... 0x....      BL       USART_SendData
    308                          if(word == (uint16_t)'1') {
   \       0x26   0xB2A4             UXTH     R4,R4
   \       0x28   0x2C31             CMP      R4,#+49
   \       0x2A   0xD103             BNE.N    ??USART2_IRQHandler_1
    309                                  usartFlag = 0;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x....             LDR.N    R1,??DataTable16_12
   \       0x30   0x6008             STR      R0,[R1, #+0]
   \       0x32   0xE002             B.N      ??USART2_IRQHandler_2
    310                          }
    311                          else {
    312                                  
    313                                  usartFlag = 1;
   \                     ??USART2_IRQHandler_1: (+1)
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0x....             LDR.N    R1,??DataTable16_12
   \       0x38   0x6008             STR      R0,[R1, #+0]
    314                          }
    315                      
    316                      USART_ClearITPendingBit(USART2,USART_IT_RXNE);
   \                     ??USART2_IRQHandler_2: (+1)
   \       0x3A   0x0031             MOVS     R1,R6
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0x.... 0x....      BL       USART_ClearITPendingBit
    317                  }
    318          }
   \                     ??USART2_IRQHandler_0: (+1)
   \       0x42   0xBD70             POP      {R4-R6,PC}
    319          

   \                                 In section .text, align 2, keep-with-next
    320          void EXTI15_10_IRQHandler() {
   \                     EXTI15_10_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    321              if (EXTI_GetITStatus(EXTI_Line11) != RESET) {
   \        0x2   0xF44F 0x6000      MOV      R0,#+2048
   \        0x6   0x.... 0x....      BL       EXTI_GetITStatus
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD013             BEQ.N    ??EXTI15_10_IRQHandler_0
    322                  if (GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_11) == Bit_RESET){
   \        0xE   0xF44F 0x6100      MOV      R1,#+2048
   \       0x12   0x....             LDR.N    R0,??DataTable16_2
   \       0x14   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD108             BNE.N    ??EXTI15_10_IRQHandler_1
    323                      btnFlag = (btnFlag == 0) ? 1 : 0;
   \       0x1C   0x....             LDR.N    R1,??DataTable16_13
   \       0x1E   0x6808             LDR      R0,[R1, #+0]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD102             BNE.N    ??EXTI15_10_IRQHandler_2
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x6008             STR      R0,[R1, #+0]
   \       0x28   0xE001             B.N      ??EXTI15_10_IRQHandler_1
   \                     ??EXTI15_10_IRQHandler_2: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x6008             STR      R0,[R1, #+0]
    324                      
    325                  }
    326          
    327                  EXTI_ClearITPendingBit(EXTI_Line11);
   \                     ??EXTI15_10_IRQHandler_1: (+1)
   \       0x2E   0xF44F 0x6000      MOV      R0,#+2048
   \       0x32   0x.... 0x....      BL       EXTI_ClearITPendingBit
    328              }
    329          }
   \                     ??EXTI15_10_IRQHandler_0: (+1)
   \       0x36   0xBD01             POP      {R0,PC}
    330          

   \                                 In section .text, align 2, keep-with-next
    331          void DMA1_Channel1_IRQHandler(void)
    332          {
   \                     DMA1_Channel1_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    333                  if(DMA_GetITStatus(DMA1_IT_TC1)){
   \        0x2   0x2002             MOVS     R0,#+2
   \        0x4   0x.... 0x....      BL       DMA_GetITStatus
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD00F             BEQ.N    ??DMA1_Channel1_IRQHandler_0
    334                          gasFlag = (ADC_Value[0] > GASMAX) ? 1: 0;
   \        0xC   0x....             LDR.N    R0,??DataTable16_6
   \        0xE   0x8800             LDRH     R0,[R0, #+0]
   \       0x10   0xF240 0x3121      MOVW     R1,#+801
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xDB03             BLT.N    ??DMA1_Channel1_IRQHandler_1
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x....             LDR.N    R1,??DataTable16_14
   \       0x1C   0x6008             STR      R0,[R1, #+0]
   \       0x1E   0xE002             B.N      ??DMA1_Channel1_IRQHandler_2
   \                     ??DMA1_Channel1_IRQHandler_1: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x....             LDR.N    R1,??DataTable16_14
   \       0x24   0x6008             STR      R0,[R1, #+0]
    335                          DMA_ClearITPendingBit(DMA1_IT_GL1);
   \                     ??DMA1_Channel1_IRQHandler_2: (+1)
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0x.... 0x....      BL       DMA_ClearITPendingBit
    336                  }
    337          }
   \                     ??DMA1_Channel1_IRQHandler_0: (+1)
   \       0x2C   0xBD01             POP      {R0,PC}
    338          
    339          

   \                                 In section .text, align 2, keep-with-next
    340          void ControlPWM(int PWM) {
   \                     ControlPWM: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    341                  TIM_OCInitTypeDef       TIM_OCInitStructure;
    342                  
    343                  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
   \        0x2   0x2160             MOVS     R1,#+96
   \        0x4   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    344                  TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0xF8AD 0x1008      STRH     R1,[SP, #+8]
    345                  TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    346                  TIM_OCInitStructure.TIM_Pulse = PWM;
   \       0x14   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    347                  TIM_OC3Init(TIM3, &TIM_OCInitStructure);
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0x....             LDR.N    R0,??DataTable16_9
   \       0x1C   0x.... 0x....      BL       TIM_OC3Init
    348          }
   \       0x20   0xB005             ADD      SP,SP,#+20
   \       0x22   0xBD00             POP      {PC}
    349          

   \                                 In section .text, align 2, keep-with-next
    350          void SetFireAlarm()
    351          {
   \                     SetFireAlarm: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    352                  GPIO_SetBits(GPIOC, GPIO_Pin_8);
   \        0x2   0x....             LDR.N    R4,??DataTable16_3
   \        0x4   0xF44F 0x7180      MOV      R1,#+256
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       GPIO_SetBits
    353                  GPIO_SetBits(GPIOC, GPIO_Pin_9);
   \        0xE   0xF44F 0x7100      MOV      R1,#+512
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0x.... 0x....      BL       GPIO_SetBits
    354                  ControlPWM(1000);
   \       0x18   0xF44F 0x707A      MOV      R0,#+1000
   \       0x1C   0x.... 0x....      BL       ControlPWM
    355          }
   \       0x20   0xBD10             POP      {R4,PC}
    356          

   \                                 In section .text, align 2, keep-with-next
    357          void ResetFireAlarm()
    358          {
   \                     ResetFireAlarm: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    359                  GPIO_ResetBits(GPIOC, GPIO_Pin_8);
   \        0x2   0x....             LDR.N    R4,??DataTable16_3
   \        0x4   0xF44F 0x7180      MOV      R1,#+256
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       GPIO_ResetBits
    360                  GPIO_ResetBits(GPIOC, GPIO_Pin_9);
   \        0xE   0xF44F 0x7100      MOV      R1,#+512
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0x.... 0x....      BL       GPIO_ResetBits
    361                  
    362                  ControlPWM(2000);
   \       0x18   0xF44F 0x60FA      MOV      R0,#+2000
   \       0x1C   0x.... 0x....      BL       ControlPWM
    363          }
   \       0x20   0xBD10             POP      {R4,PC}
    364          

   \                                 In section .text, align 2, keep-with-next
    365          char GetLCDNumber(uint16_t x, uint16_t y)
    366          {
   \                     GetLCDNumber: (+1)
   \        0x0   0xB47E             PUSH     {R1-R6}
    367                  char keypad[4][3] = {
    368                                  { '1', '2', '3' },
    369                                  { '4', '5', '6' },
    370                                  { '7', '8', '9'},
    371                                  { '*', '0', '#' },
    372                  };
   \        0x2   0x466A             MOV      R2,SP
   \        0x4   0x....             LDR.N    R3,??DataTable16_15
   \        0x6   0xE893 0x0070      LDM      R3,{R4-R6}
   \        0xA   0xE882 0x0070      STM      R2,{R4-R6}
    373            
    374                  // 2차원 배열 - x / 80 + 1, y / 80 + 1로 처리
    375                  char result = 'a';
   \        0xE   0x2261             MOVS     R2,#+97
    376                  if(x >= 999 || y >= 999) {
   \       0x10   0xF240 0x32E7      MOVW     R2,#+999
   \       0x14   0x0003             MOVS     R3,R0
   \       0x16   0xB29B             UXTH     R3,R3
   \       0x18   0x4293             CMP      R3,R2
   \       0x1A   0xDA03             BGE.N    ??GetLCDNumber_0
   \       0x1C   0x000B             MOVS     R3,R1
   \       0x1E   0xB29B             UXTH     R3,R3
   \       0x20   0x4293             CMP      R3,R2
   \       0x22   0xDB01             BLT.N    ??GetLCDNumber_1
    377                          result = 'a';
   \                     ??GetLCDNumber_0: (+1)
   \       0x24   0x2061             MOVS     R0,#+97
   \       0x26   0xE00C             B.N      ??GetLCDNumber_2
    378                  }
    379                  else{
    380                          result = keypad[x / (80+1)][y / (80+1)];
   \                     ??GetLCDNumber_1: (+1)
   \       0x28   0xB289             UXTH     R1,R1
   \       0x2A   0x2251             MOVS     R2,#+81
   \       0x2C   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \       0x30   0xB280             UXTH     R0,R0
   \       0x32   0x2251             MOVS     R2,#+81
   \       0x34   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \       0x38   0x2003             MOVS     R0,#+3
   \       0x3A   0x4342             MULS     R2,R0,R2
   \       0x3C   0x4668             MOV      R0,SP
   \       0x3E   0x4410             ADD      R0,R0,R2
   \       0x40   0x5C40             LDRB     R0,[R0, R1]
    381                  }
    382          
    383                  return result;
   \                     ??GetLCDNumber_2: (+1)
   \       0x42   0xB2C0             UXTB     R0,R0
   \       0x44   0xBC7E             POP      {R1-R6}
   \       0x46   0x4770             BX       LR
    384          }
    385          

   \                                 In section .text, align 2, keep-with-next
    386          void Delay(void) {
    387          	int i;
    388          	for (i = 0; i < 500000; i++) {}
   \                     Delay: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0xE000             B.N      ??Delay_0
   \                     ??Delay_1: (+1)
   \        0x4   0x1C40             ADDS     R0,R0,#+1
   \                     ??Delay_0: (+1)
   \        0x6   0x....             LDR.N    R1,??DataTable16_16
   \        0x8   0x4288             CMP      R0,R1
   \        0xA   0xDBFB             BLT.N    ??Delay_1
    389          }
   \        0xC   0x4770             BX       LR
    390          

   \                                 In section .text, align 2, keep-with-next
    391          int main(void)
    392          {
   \                     main: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    393                  SystemInit();
   \        0x2   0x.... 0x....      BL       SystemInit
    394                  RCCInit();
   \        0x6   0x.... 0x....      BL       RCCInit
    395                  
    396                  GpioInit();
   \        0xA   0x.... 0x....      BL       GpioInit
    397                  EXTI_Configure();
   \        0xE   0x.... 0x....      BL       EXTI_Configure
    398                  DMA_Configure();
   \       0x12   0x.... 0x....      BL       DMA_Configure
    399                  ADC_Configure();
   \       0x16   0x.... 0x....      BL       ADC_Configure
    400                  TIM_Configure();
   \       0x1A   0x.... 0x....      BL       TIM_Configure
    401                  USART1_Init();
   \       0x1E   0x.... 0x....      BL       USART1_Init
    402                  USART2_Init();
   \       0x22   0x.... 0x....      BL       USART2_Init
    403                  NVIC_Configure();
   \       0x26   0x.... 0x....      BL       NVIC_Configure
    404                   
    405                  GPIO_ResetBits(GPIOC, GPIO_Pin_8);
   \       0x2A   0x....             LDR.N    R4,??DataTable16_3
   \       0x2C   0xF44F 0x7180      MOV      R1,#+256
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       GPIO_ResetBits
    406                  GPIO_ResetBits(GPIOC, GPIO_Pin_9);
   \       0x36   0xF44F 0x7100      MOV      R1,#+512
   \       0x3A   0x0020             MOVS     R0,R4
   \       0x3C   0x.... 0x....      BL       GPIO_ResetBits
   \       0x40   0xE00E             B.N      ??main_0
    407          
    408                  while(1) {
    409                          if(usartFlag) {
    410                                  ResetFireAlarm();
    411                          } else {
    412                                  if(btnFlag || gasFlag) {
    413                                          SetFireAlarm();
    414                                  }
    415                                  else {
    416                                          ResetFireAlarm();
   \                     ??main_1: (+1)
   \       0x42   0x.... 0x....      BL       ResetFireAlarm
   \       0x46   0xE009             B.N      ??main_2
    417                                  }
   \                     ??main_3: (+1)
   \       0x48   0x....             LDR.N    R0,??DataTable16_13
   \       0x4A   0x6800             LDR      R0,[R0, #+0]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD103             BNE.N    ??main_4
   \       0x50   0x....             LDR.N    R0,??DataTable16_14
   \       0x52   0x6800             LDR      R0,[R0, #+0]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD0F4             BEQ.N    ??main_1
   \                     ??main_4: (+1)
   \       0x58   0x.... 0x....      BL       SetFireAlarm
    418                          }
    419                          
    420                          Delay();
   \                     ??main_2: (+1)
   \       0x5C   0x.... 0x....      BL       Delay
   \                     ??main_0: (+1)
   \       0x60   0x....             LDR.N    R0,??DataTable16_12
   \       0x62   0x6800             LDR      R0,[R0, #+0]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD0EF             BEQ.N    ??main_3
   \       0x68   0x.... 0x....      BL       ResetFireAlarm
   \       0x6C   0xE7F6             B.N      ??main_2
    421                  }
    422          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0x4001'0800        DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0x4001'1400        DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \        0x0   0x4001'1000        DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \        0x0   0x4001'0C00        DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \        0x0   0x4001'244C        DC32     0x4001244c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \        0x0   0x....'....        DC32     ADC_Value

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \        0x0   0x4002'0008        DC32     0x40020008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \        0x0   0x4001'2400        DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \        0x0   0x4000'0400        DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \        0x0   0x4001'3800        DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \        0x0   0x4000'4400        DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \        0x0   0x....'....        DC32     usartFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \        0x0   0x....'....        DC32     btnFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \        0x0   0x....'....        DC32     gasFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \        0x0   0x0007'A120        DC32     0x7a120

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x31 0x32          DC8 49, 50, 51, 52, 53, 54, 55, 56, 57, 42, 48, 35

   \              0x33 0x34    

   \              0x35 0x36    

   \              0x37 0x38    

   \              0x39 0x2A    

   \              0x30 0x23

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   ADC_Configure
        32   -> ADC_Cmd
        32   -> ADC_DMACmd
        32   -> ADC_GetCalibrationStatus
        32   -> ADC_GetResetCalibrationStatus
        32   -> ADC_Init
        32   -> ADC_RegularChannelConfig
        32   -> ADC_ResetCalibration
        32   -> ADC_SoftwareStartConvCmd
        32   -> ADC_StartCalibration
      24   ControlPWM
        24   -> TIM_OC3Init
       8   DMA1_Channel1_IRQHandler
         8   -> DMA_ClearITPendingBit
         8   -> DMA_GetITStatus
      56   DMA_Configure
        56   -> DMA_Cmd
        56   -> DMA_ITConfig
        56   -> DMA_Init
       0   Delay
       8   EXTI15_10_IRQHandler
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> GPIO_ReadInputDataBit
      16   EXTI_Configure
        16   -> EXTI_Init
        16   -> GPIO_EXTILineConfig
      24   GetLCDNumber
      16   GpioInit
        16   -> GPIO_Init
       8   NVIC_Configure
         8   -> NVIC_Init
         8   -> NVIC_PriorityGroupConfig
         8   -> __NVIC_EnableIRQ
       8   RCCInit
         8   -> RCC_AHBPeriphClockCmd
         8   -> RCC_APB1PeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd
       8   ResetFireAlarm
         8   -> ControlPWM
         8   -> GPIO_ResetBits
       8   SetFireAlarm
         8   -> ControlPWM
         8   -> GPIO_SetBits
      40   TIM_Configure
        40   -> TIM_ARRPreloadConfig
        40   -> TIM_Cmd
        40   -> TIM_OC3Init
        40   -> TIM_OC3PreloadConfig
        40   -> TIM_TimeBaseInit
      16   USART1_IRQHandler
        16   -> USART_ClearITPendingBit
        16   -> USART_GetITStatus
        16   -> USART_ReceiveData
        16   -> USART_SendData
      24   USART1_Init
        24   -> USART_Cmd
        24   -> USART_ITConfig
        24   -> USART_Init
      16   USART2_IRQHandler
        16   -> USART_ClearITPendingBit
        16   -> USART_GetITStatus
        16   -> USART_ReceiveData
        16   -> USART_SendData
      24   USART2_Init
        24   -> USART_Cmd
        24   -> USART_ITConfig
        24   -> USART_Init
       0   __NVIC_EnableIRQ
       8   main
         8   -> ADC_Configure
         8   -> DMA_Configure
         8   -> Delay
         8   -> EXTI_Configure
         8   -> GPIO_ResetBits
         8   -> GpioInit
         8   -> NVIC_Configure
         8   -> RCCInit
         8   -> ResetFireAlarm
         8   -> SetFireAlarm
         8   -> SystemInit
         8   -> TIM_Configure
         8   -> USART1_Init
         8   -> USART2_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
      12  ?_0
     120  ADC_Configure
       2  ADC_Value
      36  ControlPWM
      46  DMA1_Channel1_IRQHandler
      92  DMA_Configure
      14  Delay
      56  EXTI15_10_IRQHandler
      42  EXTI_Configure
      72  GetLCDNumber
     178  GpioInit
     180  NVIC_Configure
      98  RCCInit
      34  ResetFireAlarm
      34  SetFireAlarm
     102  TIM_Configure
      46  USART1_IRQHandler
      70  USART1_Init
      68  USART2_IRQHandler
      70  USART2_Init
      30  __NVIC_EnableIRQ
       4  btnFlag
       4  gasFlag
       4  idx
     110  main
       4  password
       4  usartFlag
       4  wrongcnt
       4  wrongflag

 
    26 bytes in section .bss
     4 bytes in section .data
    12 bytes in section .rodata
 1'566 bytes in section .text
 
 1'566 bytes of CODE  memory
    12 bytes of CONST memory
    30 bytes of DATA  memory

Errors: none
Warnings: none
